## 1.java8有哪些新特性，你都使用过哪些？

* lambda表达式：更加简洁了，针对那些函数式接口（Function Interface）可以使用lambda表达式

* stream及其相关的一些流式操作

  我们可以对包含一个或者多个元素的的集合做各种操作。这些操作可以是中间操作或者是终端操作哦，终端操作会返回一个结果，而中间操作还是会返回一个Stream流。常用的操作有：

  * filter：过滤
  * map：转换
  * collect：转换成集合或者列表或者map
  * match：匹配，包含 allMatch、anyMatch等等
  * count：计数
  * reduce：*减少、缩小*。通过入参的 `Function`，我们能够将 `list` 归约成一个值。它的返回类型是 `Optional` 类型。 

  流又有顺序流和并行流，当数据量很大时，基于并行流的操作速度会明显加快

  ```java
  List<String> strings = Arrays.asList("Hello", "Java", "8", "!");
  // 创建顺序流，顺序流是单线程的
  Stream<String> stream = strings.stream();
  // 创建并行流
  Stream<String> stringStream = strings.parallelStream();
  ```

* Optional

  Optional他不是一个函数式接口，设计它的目的是为了防止空指针异常。我们可以将

  Optional看做是包装对象（可能是null，也可能非null）的容器。

* 方法接口（函数式接口）

  除default方法外只有一个抽象方法的接口，可以用`@FunctionInterface` 注解标注，例如：

  ```java
  @FunctionalInterface
  public interface MyFunctionInterface {
      default void test(){
          
      }
      String subBlank(String s);
  }
  ```

  `java.util.function` 包下面给我们提供了许多的函数式接口，例如Predicate（断言，判断）、Consumer（消费）、BiConsumer（消费两个）、Supplier（生产者）、Comparator（比较者）等等等等

* 方法引用

  通过`::` 来引用方法或者构造器，例如：

  ```java
  @Data
  public class Apple {
      // 颜色
      private String color;
      // 重量
      private Double weight;
      // 价格
      private Double price;
  }
  
  // 静态方法
  Function<Integer, String> function_0 = String::valueOf;
  // 实例方法
  Function<Apple, String> function_1 = Apple::getColor;
  ```

* 新的日期相关的API，例如LocalDateTime、LocalDate、LocalTIme等等

* 方法中允许添加默认（default）接口

* 静态导入

  ```java
  import static java.util.UUID.*;
  
  public class StaticImport {
      public static void main(String[] args) {
          UUID hello = fromString("hello");
      }
  }
  ```

**Stream深入理解：**

Stream作为Java 8的新特性之一，它与Java IO包中的InputStream和OutStream完全不是一个概念。Java 8中的Stream是对集合功能的一种增强，主要用于对集合对象的进行简单高效的聚合和大批量的数据操作，结合Lambda表达式可以提高开发效率和代码可读性。

特点（重点）：

1. 无存储。它不是一种数据结构，只是某种数据源的一种视图（想想数据库中的视图，数据库视图可以看做是一个移动的窗口，通过它可以看到感兴趣的的数据；stream流可以铜鼓各种filter、map、match...从而给我们返回感兴趣的数据）。
2. 对Stream的操作会产生一个结果，但是Stream并不会改变数据源，比如对stream进行过滤操作会过滤掉一些元素从而产生一个新的stream，但是数据源并没有被改变；
3. 惰式执行。Stream上的操作不会立即执行，只有等到用户真正需要结果的时候才会执行，例如这句代码并不会真正的执行`menu.stream().filter(c -> c.getCalories() > 100);`
4. 只会被消费一次。stream只能被消费一次，一旦遍历以后就会失效，就像容器的迭代器那样，要想再次遍历必须重新生成。



## 2.Stream中的foreach对比列表的For-Each带来了那些优化？

例如我们把一个列表中的所有形状设置成红色，利用for-each我们可以这么做：

**第一种**：

```java
for (Shape shape : shapes){
    shape.setColor(RED)
}
```

**第二种**：使用java8扩展后的的集合框架则可以这样写:

```java
shapes.foreach(s -> s.setColor(RED));
```

**第一种**写法我们叫外部迭代，for-each调用`shapes`的`iterator()`依次遍历集合中的元素。这种外部迭代有一些问题：

- for循环是串行的，而且必须按照集合中元素的顺序依次进行；
- 集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。

**第二种**写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。**用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等**）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。

外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而**内部迭代只负责做什么**，**而把怎么做留给类库**。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。

 

 

 

 