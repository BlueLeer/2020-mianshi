## 1.谈谈MySQL客户端和服务端的连接过程

我们知道MySQL是C/S架构，即客户端/服务端架构，客户端和服务端是两个进程，客户端进程向服务端进程发送请求并得到回复的过程是一个进程间通信的过程。MySQL支持TCP/IP、命名管道和共享内存、Unix域套接字文件这三种客户端和服务端之间的通信方式。一般来说肯定TCP/IP连接方式用的最多了。MySQL客户端发起请求连接时，会携带socket（ip地址+端口号）、用户名、密码等等信息，服务端校验用户名和密码还有权限，用来判断是否允许连接到数据库实例。



## 2.说说MySQL的基本架构

客户端 -> 连接管理（连接器） -> 查询缓存 -> 语法分析（分析器） -> 查询优化（优化器） -> 执行器 -> 引擎 -> 文件系统

几点说明：

1. 连接管理（连接器）：每当有一个客户端连接到服务器的时候，服务器就会创建一个线程专门用来处理该连接对应的客户端和服务端之间的一些交互（增删改查请求），当客户端退出连接时，该线程被释放，但是不会被立即回收销毁，而是会将它缓存起来，以供下个请求使用（因为线程的创建和销毁本来就是重量级的）。但是线程分配的太多又会影响系统性能，因此需要控制连接到服务器的客户端的数量。当连接建立的时候，负责的线程会一直等待客户端的请求，如果一段时间以后（默认是8小时），客户端没有和服务端交互，连接就会自动断开，这个时间参数是`wait_timeout`控制的。
2. 查询缓存：MySQL服务器处理**查询请求**时，会将刚刚处理过的查询请求及结果缓存起来，如果下次有一模一样的请求过来的时候，就可以直接去缓存里面取，不用去底层查找了。这个缓存可以在不同的客户端之间共享（相当于MySQL服务端维护了一个map，key是查询语句，value是查询结果。需要注意的是：如果两个查询请求的语句有稍稍的不同，例如空格、注释、大小写等等，都会导致缓存不能命中）。另外如果查询请求中包含了一些系统表，那么请求和结果就不会缓存。缓存非常容易失效，只要该表的数据被修改（使用了insert、update、delete、truncate table、alter table、drop table、drop database）都会导致该表的所有缓存变为无效并被删除。因此慎用mysql自己的缓存，一般改用缓存中间件，例如redis。MySQL 5.7开始已经不推荐使用mysql缓存了，并且MySQL 8.0以后，缓存被删除了。
3. 语法解析：客户端发过来的只是文本，需要对这些文本做一些处理，比如提取出表名、列表、关键字，判断语法是否正确等等。
4. 查询优化：我们表中有索引，优化会确认使用哪个索引；对执行顺序进行优化，条件那么多，先查哪个表，再查那个表，还是先关联，最后由优化器确定到底使用哪种方案。
5. 执行器：执行器调用存储引擎的提供的API，具体的任务就会落到具体的存储引擎上，例如InnoDB或者MyISAM。我们知道表是一行行的记录构成的，但是这些都是逻辑概念，物理上如何表示，怎么从表中读取数据，怎么把数据放到磁盘上，这些都是存储引擎干的事情。
6. 存储引擎：下面详细再说。



## 3.说说InnoDB和MyISAM的区别。

比较之前，肯定要先简单说说。

### 3.1 InnoDB

* 页

  InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机重启以后我们的数据还是存在的。读写都是需要先将磁盘上的数据加载到内存，然后再进行一些处理，如果是数据的修改，还要将修改后的数据再保存到磁盘上。这就涉及到内存和磁盘数据的交互了，**页**是MySQL中磁盘和内存交互的基本单位。InnoDB将数据分为若干个页，以页作为内存和磁盘交互的基本数据单位，InnoDB中页的大小一般为16KB，也就是一般情况下，一次最少从磁盘上读取16KB的数据到内存中，然后再进行处理。**数据页之间是双向链表。**

* 行格式

  行构成了页，MySQL中表的一行数据对应一个行格式。InnoDB默认有四种行格式：Compact、Redundant、Dynamic、Compressed。InnoDB默认是Dynamic。

  一个页通常是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存放在其他页中，这种现象称为**行溢出**。

* 一个数据页有许多个行构成的（如果放不下，就会放到后面的页中去）

* InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的偏移量作为一个槽，存放在Page Directory中，所以在一个页中个根据主键查找是非常快的：

  1. 通过二分法二分法确定记录所在的槽
  2. 通过记录的next_record属性遍历该槽中所有的记录进行主键匹配。

**总结来说（重点）：**

1. 各个数据页可以组成一个双向链表
2. 而每个数据页中的记录又可以组成一个单向链表
3. 每个数据页都会为存在其中的行记录维护一个页目录，通过主键查找某条记录的时候可以在页目录中通过二分查找法快速定位到对应的槽（啥是槽？InnoDB会将页中记录划分为若干个组，每个组最后一个记录的偏移量作为一个槽，存放在Page Directory中），然后再遍历槽中的数据就可以找到对应的记录了
4. 以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录

### 3.2 InnoDB和MyISAM的主要区别

| 方面         | InnoDB | MyISAM |
| :----------- | ------ | ------ |
| 事务         | 支持   | 不支持 |
| 外键         | 支持   | 不支持 |
| 行级锁       | 支持   | 不支持 |
| 自动奔溃恢复 | 支持   | 不支持 |
|              |        |        |

还有：MySQL 5.1及之前的版本中，MyISAM是默认的存储引擎，而在MySQL 5.5之后，InnoDB称为了MySQL默认的存储引擎。MyISAM会对整张表加锁，而不是针对行加锁；MyISAM数据可被压缩，存储空间很少，而且MyISAM在筛选大数据时非常快。

InnoDB是事务型引擎，当事务异常提交时，会被回滚。同时，InnoDB支持行锁。此外InnoDB需要更多的存储空间，它会在内存中建立其专门的缓冲池用于高速缓冲数据和索引。InnoDB支持自动崩溃恢复特性。

某些情况下，使用MyISAM也是比较适合的，例如读密集的情况下。

上面这么多不同点，随便抓一个，就能成为一个考点。



### 3.3 说说InnoDB和MyISAM使用B+Tree实现原理的不同

* MyISAM

  叶子结点包括了key和value，key存放的是索引，value存的是数据地址（可以理解为行记录的地址）。在根据索引检索的时候，如果指定的key存在，则取出value的值，然后根据这个值为地址去读取相应的记录。这被称为**非聚簇索引**，也叫非聚集索引（即索引和数据是分开的）。

* InnoDB

  根据主索引（primary key是默认的主索引，如果没有则取unique的列为主索引，如果连unique都没有，那就弄个row_id）构建一个B+树的索引数据结构，它的叶子结点data域保存了完整的数据记录，也就是说InnoDB的数据文件本身就是索引，这也是“聚簇索引”的由来。除了主索引，我们还可以创建其他的索引，例如：

  ```sql
  create table people(id int primary key, name varchar(20));
  -- 上面以已经指定了一个主键，所以它默认就有主索引了，接下来我们添加一个普通索引，这个普通索引也是二级索引
  ALTER TABLE people ADD INDEX index_n(name);
  ```

  **在根据主索引搜索时，找到叶子结点后，直接找到key所对应的节点即可取出数据；在根据辅助索引进行搜索时，叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。**



## 4. 什么是索引

是一种**快速查询**表中内容的机制（意思是为了查询而生的），类似书的目录，引用在表中某些个字段之上，但存储时独立于表之外。

我们可以把索引表当做是表和行记录（构成数据页的东东，把它们叫做行记录，或者行格式）的中间表，它维护了表的索引列到物理数据地址之间的映射。

在InnoDB数据页中，行记录是根据主键（如果没有主键，也没有unique的列，则会生成隐藏的rowid作为“主键”）排列起来，并且所有的记录呈现一个单链表的形态（通过next_record指向下个记录）。查询的时候，先去匹配索引，然后根据索引对应的数据的行位置去提取数据。

创建索引的语句：

```mysql
-- 创建索引的语句
-- 1.添加PRIMARY KEY（主键索引） 
mysql>ALTER TABLE table_name ADD PRIMARY KEY (column_name);
-- 2.添加UNIQUE(唯一索引) 
mysql>ALTER TABLE table_name ADD UNIQUE (column) ;
-- 添加主键列和唯一列都会默认添加索引
------------------------------------------------------------
-- 3.添加INDEX(普通索引) 
mysql>ALTER TABLE table_name ADD INDEX index_name (column); 
-- 4.添加FULLTEXT(全文索引) 
mysql>ALTER TABLE table_name ADD FULLTEXT (column);
-- 5.添加多列索引,也叫联合索引,添加到多列上面的
mysql>ALTER TABLE table_name ADD INDEX index_name (column1, column2, column3);
```



## 5.索引有哪些特点

1. 索引一旦建立，数据库系统（MySQL或者Oracle）会对他们进行自动维护，插入、修改、删除只要涉及到索引改变的，都会使得索引表进行更新
2. 用户不用显示的指定在查询语句中指定使用那些索引。
3. 在定义的`primary key` 或者 `unique` 约束后系统会自动在相应的列上创建索引
4. 用户也能根据自己的需求，对指定单个字段或多个字段，添加索引



## 6.什么时候应该要创建索引

1. 表经常进行`select`操作
2. 表的记录很多，记录内容分布范围很广（如果不建立索引，全表扫描耗时相对来说会很长）
3. 列名经常在where子句或者连接条件中出现（查询场景很多，而且很多时候是带where的条件查询，因为有了索引以后就不用进行全表扫描了，能根据索引快速定位到数据页，找到符合条件的数据）



## 7. 什么时候不应该创建索引

1. 表经常更新（insert、update、delete），因为表数据更新以后，对应的索引也会进行更新
2. 表很小（记录超少），建立索引去优化一张小表的查询**性价比**太低
3. 列表经常不作为连接条件或出现在where子句中
4. 对于哪些定义为text，image和bit数据类型的列不应该创建索引，这是因为这些数据要么特别大，要么取值很少。



## 8.索引有哪些优缺点

任何事物都有两面性，索引也不例外，它的优点有：

1. 唯一索引，保证了数据库表中数据的唯一性
2. 使用索引，可以在查询中，使用优化隐藏器（优化器）提供性能，减少磁盘IO，从而加快数据检索速度。在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强调该列的唯一性和组织表中数据的排列结构（想想一个数据页中的数据都是按照主键排列的，他们呈现出单链表的形态）；在经常用在连接的列上，这些列主要是一些外键，可以加快连接速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定范围内的数据是连续的；在经常需要排序的列上创建索引，因为索引已经排好序，这样查询可以利用索引的排序，加快排序所用的时间；在经常使用在where子句中的列上面创建索引，加快条件的判断速度。

它的缺点有：

1. 占用额外的物理空间，特别是聚集索引，需要较大的空间
2. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度，并且随着数据量的增大，耗费的时间会越来越多。





来吧，尝试几道面试题，检验下自己：<https://www.cnblogs.com/gaoquanquan/p/11030999.html>





-------------------------------------------------------

以下面试总结根据：<https://juejin.im/post/5e6509fd518825490d1267eb> 总结而来，有的题目只是简单的理解后摘录过来，有的是在原答案基础上进行融会贯通而来的，仅限自己的理解，记录自己的学习过程。



## 1.说说MySQL数据库索引的相关知识吧，索引有哪些数据结构？

索引有Hash和B+树两种数据结构。在MySQL数据库中，我们创建索引的时候可以指定索引类型，有`HASH`和`BTREE`的选项。我们创建表的时候指定了 `primary key` 和 `unique` 的列会自动给我们创建BTREE类型的索引表。



## 2. 说说为什么要用B+树，而不用Hash表、完全平衡二叉树、B树这些呢？

回答这个问题我们要明白这几种数据结构的优缺点。

- **Hash表**

  它是根据索引列的值通过Hash算法找到数组下标（Hash表实际上是一个数组，字段值所对应的数组下标是哈希算法随机算出来的，所以可能出现**哈希冲突**），拿到数据，这个数据相当于行记录的地址，然后去读取这个地址上的值，这样就完成了查询。但是它对于：

  ```mysql
  select * from user where name > '张三';
  ```

  这样的查询语句就无能为力了呀，因为Hash表是无序的数组，此时就要进行全表扫描了。因此我们可以总结：

  **Hash表的特点是可以快速的进行精确查询（等值查询），但是不支持范围查询。**

  > Hash表在那些场景下比较适合？
  >
  > 等值查询的场景，就是利用Key-Value的情况，例如Redis、Memcached等这些NoSQL的中间件。
  >
  > Hash表是无序的，等值查询效率很高，能不能让Hash表排个序，这样等值查询和范围查询都很好呀？
  >
  > 可以的，也就是有序数组，但是维护这样一张有序的Hash表成本很大呀，数据的更新修改删除都会导致数组耗费大量的时间来调整，因此它比较适合做哪些静态数据。例如你去年一年的信用卡消费账单就比较适合用这种数据结构来存储。

- **完全平衡二叉树**

  它是有序的，所以支持范围查找，但是查找时，它是时间复杂度是`O(Log(N))`，为了维持它的平衡，更新时时间复杂度也是`O(Log(N))`。另外，如果索引数据很多（例如几千万的数据），那么树会很高，查询的成本就会随着树高的增加而增加，如果数据是放在机械硬盘里面的，速度会更慢。

- **B树**

  B树要比二叉树要矮，结点可以存储多个关键字，关键字是有序的，范围查询时通过结点的关键字也能快速定位到数据所在的子树，它本身就很优秀了。但是B+树是它的升级版，更优秀。

- **B+树**

  B+树是B树的升级版，它比B树还要矮，这样磁盘的IO次数可以进一步降低；B+树非叶子结点不存放数据，因此相同的空间下可以支持更多的索引；并且叶子结点有指向下个叶子结点的指针，这样范围查询的效率会更高

  > 一个B+树的结点到底多大合适?
  >
  > 数据页的整数倍比较合适，因为MySQL使用的InnoDB引擎磁盘和内存的交互单位是数据页（数据页大小一般是16KB）







## 3.说说select * from user where account = 'zhangsan'这条语句的底层的查询过程，其中id为user表的主键。

分两种情况：

* account上有索引

  1. 根据关键字zhangsan找到对应的id值，假如为002（id为主键）
  2. 根据id值定位到数据所在的数据页（数据页之间是双向链表关联的，所以是双向遍历）
  3. 找到数据页以后，再单向遍历行数据（因为行数据之间是单链表），找到对应id=002对应的数据行
  4. over

  以上过程就是**回表**。回到主键索引树搜索的过程就是回表。避免回表也有方法，那就是**覆盖索引**。

  > 啥叫**覆盖索引**？
  >
  > 例如我们在id上有个索引，它是主键索引，另外还有个name也是个索引。它在B+树中每个节点存在的形式是`(3,'zhangsan'),(8,'lisi')`，可以看到索引的关键字是由主键id和name组合起来的。如果我们不用`select * from user where account = 'zhangsan';`，而改用`select id from user where account = 'zhangsan'`，这样在通过‘zhangsan’ 找到节点以后，发现上面已经有id了，直接返回即可，不用回到主键ID去查询。
  >
  > 很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率。

* account上没有索引

  what？没有索引，那你去全表扫描吧！



## 4. 说说最左匹配原则（重点）

简单来说，如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如, 如果你创建了一个三列的联合索引包含(col1, col2, col3)，你的索引会生效于(col1), (col1, col2), 以及(col1, col2, col3)。

举个栗子（来源于<https://juejin.im/post/5da53e04e51d45782f663c04>）：

```mysql
CREATE TABLE user (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
```

其中我们定义了一个联合索引name，包含的列为last_name和first_name。该索引可以用于为`last_name`和`first_name`值的组合指定一个已知范围内的查询. 同样也可以用于只指定了`last_name`列值的查询, 因为这个列是索引的一个最左前缀(就如下一节所说)。通俗来说，last_name必须放在最左边。因此，索引name可以用于下面的查询语句：

```mysql
select * from user where last_name = 'LeBron';

select * from user where last_name = 'LeBron' and first_name = 'James';

select * from user where last_name = 'LeBron' and (first_name = 'LeBron' OR last_name = 'James');

select * from user where last_name = 'LeBron' and (first_name >= 'A' and last_name <= 'M');
```

然而，索引name不能用于下列的查询：

```mysql
select * from user where first_name = 'Curry';

select * from user where last_name = 'Stephen' and first_name = 'Curry';
```

为什么会这样呢？

因为B+树中结点是按照创建联合索引时指定列的顺序排列的，关键字中的last_name是有序的，但是，first_name是无序的。例如一个结点可以是这样的:

`（dehua，liu）（huateng，ma）` last_name是有序的,但是first_name是无序的。



## 5. MySQL联合索引最多支持多少个列？

> MySQL can create composite indexes (that is, indexes on multiple columns). An index may consist of up to 16 columns. For certain data types, you can index a prefix of the column (see [Section 8.3.5, “Column Indexes”](https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html)).

MySQL官方文档。16列。



## 6. MySQL 一张表最多支持多少个索引? 

一个表最多16个索引,最大索引长度256字节。



















参考：

本文内容大部分来源于：<https://juejin.im/post/5a9ca0d6518825555c1d1acd> 

索引的最左匹配原则：<https://juejin.im/post/5da53e04e51d45782f663c04> 