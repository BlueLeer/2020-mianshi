## 1.谈谈MySQL客户端和服务端的连接过程

我们知道MySQL是C/S架构，即客户端/服务端架构，客户端和服务端是两个进程，客户端进程向服务端进程发送请求并得到回复的过程是一个进程间通信的过程。MySQL支持TCP/IP、命名管道和共享内存、Unix域套接字文件这三种客户端和服务端之间的通信方式。一般来说肯定TCP/IP连接方式用的最多了。MySQL客户端发起请求连接时，会携带socket（ip地址+端口号）、用户名、密码等等信息，服务端校验用户名和密码还有权限，用来判断是否允许连接到数据库实例。



## 2.说说MySQL的基本架构

客户端 -> 连接管理（连接器） -> 查询缓存 -> 语法分析（分析器） -> 查询优化（优化器） -> 执行器 -> 引擎 -> 文件系统

几点说明：

1. 连接管理（连接器）：每当有一个客户端连接到服务器的时候，服务器就会创建一个线程专门用来处理该连接对应的客户端和服务端之间的一些交互（增删改查请求），当客户端退出连接时，该线程被释放，但是不会被立即回收销毁，而是会将它缓存起来，以供下个请求使用（因为线程的创建和销毁本来就是重量级的）。但是线程分配的太多又会影响系统性能，因此需要控制连接到服务器的客户端的数量。当连接建立的时候，负责的线程会一直等待客户端的请求，如果一段时间以后（默认是8小时），客户端没有和服务端交互，连接就会自动断开，这个时间参数是`wait_timeout`控制的。
2. 查询缓存：MySQL服务器处理**查询请求**时，会将刚刚处理过的查询请求及结果缓存起来，如果下次有一模一样的请求过来的时候，就可以直接去缓存里面取，不用去底层查找了。这个缓存可以在不同的客户端之间共享（相当于MySQL服务端维护了一个map，key是查询语句，value是查询结果。需要注意的是：如果两个查询请求的语句有稍稍的不同，例如空格、注释、大小写等等，都会导致缓存不能命中）。另外如果查询请求中包含了一些系统表，那么请求和结果就不会缓存。缓存非常容易失效，只要该表的数据被修改（使用了insert、update、delete、truncate table、alter table、drop table、drop database）都会导致该表的所有缓存变为无效并被删除。因此慎用mysql自己的缓存，一般改用缓存中间件，例如redis。MySQL 5.7开始已经不推荐使用mysql缓存了，并且MySQL 8.0以后，缓存被删除了。
3. 语法解析：客户端发过来的只是文本，需要对这些文本做一些处理，比如提取出表名、列表、关键字，判断语法是否正确等等。
4. 查询优化：我们表中有索引，优化会确认使用哪个索引；对执行顺序进行优化，条件那么多，先查哪个表，再查那个表，还是先关联，最后由优化器确定到底使用哪种方案。
5. 执行器：执行器调用存储引擎的提供的API，具体的任务就会落到具体的存储引擎上，例如InnoDB或者MyISAM。我们知道表是一行行的记录构成的，但是这些都是逻辑概念，物理上如何表示，怎么从表中读取数据，怎么把数据放到磁盘上，这些都是存储引擎干的事情。
6. 存储引擎：下面详细再说。



## 3.说说InnoDB和MyISAM的区别。

比较之前，肯定要先简单说说。

### 3.1 InnoDB

* 页

  InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机重启以后我们的数据还是存在的。读写都是需要先将磁盘上的数据加载到内存，然后再进行一些处理，如果是数据的修改，还要将修改后的数据再保存到磁盘上。这就涉及到内存和磁盘数据的交互了，**页**是MySQL中磁盘和内存交互的基本单位。InnoDB将数据分为若干个页，以页作为内存和磁盘交互的基本数据单位，InnoDB中页的大小一般为16KB，也就是一般情况下，一次最少从磁盘上读取16KB的数据到内存中，然后再进行处理。

* 行格式

  行构成了页，MySQL中表的一行数据对应一个行格式。InnoDB默认有四种行格式：Compact、Redundant、Dynamic、Compressed。InnoDB默认是Dynamic。

  一个页通常是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存放在其他页中，这种现象称为**行溢出**。

* 一个数据页有许多个行构成的（如果放不下，就会放到后面的页中去）

* InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的偏移量作为一个槽，存放在Page Directory中，所以在一个页中个根据主键查找是非常快的：

  1. 通过二分法二分法确定记录所在的槽
  2. 通过记录的next_record属性遍历该槽中所有的记录进行主键匹配。

因为InnoDB是我们常用的，能多回答就尽可能的多回答。

### 3.2 InnoDB和MyISAM的主要区别

| 方面         | InnoDB | MyISAM |
| :----------- | ------ | ------ |
| 事务         | 支持   | 不支持 |
| 外键         | 支持   | 不支持 |
| 行级锁       | 支持   | 不支持 |
| 自动奔溃恢复 | 支持   | 不支持 |

还有：MySQL 5.1及之前的版本中，MyISAM是默认的存储引擎，而在MySQL 5.5之后，InnoDB称为了MySQL默认的存储引擎。MyISAM会对整张表加锁，而不是针对行加锁；MyISAM数据可被压缩，存储空间很少，而且MyISAM在筛选大数据时非常快。

InnoDB是事务型引擎，当事务异常提交时，会被回滚。同时，InnoDB支持行锁。此外InnoDB需要更多的存储空间，它会在内存中建立其专门的缓冲池用于高速缓冲数据和索引。InnoDB支持自动崩溃恢复特性。

上面这么多不同点，随便抓一个，就能成为一个考点。



## 4. 什么是索引

是一种**快速查询**表中内容的机制（意思是为了查询而生的），类似书的目录，引用在表中某些个字段之上，但存储时独立于表之外。

我们可以把索引表当做是表和行记录（构成数据页的东东，把它们叫做行记录，或者行格式）的中间表，它维护了表的索引列到物理数据地址之间的映射。

在InnoDB数据页中，行记录是根据主键（如果没有主键，也没有unique的列，则会生成隐藏的rowid作为“主键”）排列起来，并且所有的记录呈现一个单链表的形态（通过next_record指向下个记录）。查询的时候，先去匹配索引，然后根据索引对应的数据的行位置去提取数据。



## 5.索引有哪些特点

1. 索引一旦建立，数据库系统（MySQL或者Oracle）会对他们进行自动维护，插入、修改、删除只要涉及到索引改变的，都会使得索引表进行更新
2. 用户不用显示的指定在查询语句中指定使用那些索引。
3. 在定义的`primary key` 或者 `unique` 约束后系统会自动在相应的列上创建索引
4. 用户也能根据自己的需求，对指定单个字段或多个字段，添加索引



## 6.什么时候应该要创建索引

1. 表经常进行`select`操作
2. 表的记录很多，记录内容分布范围很广（如果不建立索引，全表扫描耗时相对来说会很长）
3. 列名经常在where子句或者连接条件中出现（查询场景很多，而且很多时候是带where的条件查询，因为有了索引以后就不用进行全表扫描了，能根据索引快速定位到数据页，找到符合条件的数据）



## 7. 什么时候不应该创建索引

1. 表经常更新（insert、update、delete），因为表数据更新以后，对应的索引也会进行更新
2. 表很小（记录超少），建立索引去优化一张小表的查询**性价比**太低
3. 列表经常不作为连接条件或出现在where子句中
4. 对于哪些定义为text，image和bit数据类型的列不应该创建索引，这是因为这些数据要么特别大，要么取值很少。



## 8.索引有哪些优缺点

任何事物都有两面性，索引也不例外，它的优点有：

1. 唯一索引，保证了数据库表中数据的唯一性
2. 使用索引，可以在查询中，使用优化隐藏器（优化器）提供性能，减少磁盘IO，从而加快数据检索速度。在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强调该列的唯一性和组织表中数据的排列结构（想想一个数据页中的数据都是按照主键排列的，他们呈现出单链表的形态）；在经常用在连接的列上，这些列主要是一些外键，可以加快连接速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定范围内的数据是连续的；在经常需要排序的列上创建索引，因为索引已经排好序，这样查询可以利用索引的排序，加快排序所用的时间；在经常使用在where子句中的列上面创建索引，加快条件的判断速度。

它的缺点有：

1. 占用额外的物理空间，特别是聚集索引，需要较大的空间
2. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度，并且随着数据量的增大，耗费的时间会越来越多。









参考：<https://juejin.im/post/5a9ca0d6518825555c1d1acd> 