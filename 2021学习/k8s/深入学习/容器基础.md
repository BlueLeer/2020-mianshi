## 容器基础

* 容器基础起源于PaaS技术的普及

  > 大概在12年的时候，Cloud Foundry作为PaaS中的大哥，他们最核心的技术是一套应用的打包和分发机制，他们为每种编程语言都定义了一种打包格式，在运行时Cloud Foundry会调用操作系统的Cgroups和NameSpace机制为每个应用单独创建一个称作沙盒和隔离环境，然后在沙盒中启动这些应用进程，这就是PaaS项目最核心的能力。
  >
  > 我们也可以看到Docker也是基于这一套，但是Docker有个不一样的功能：**Docker镜像**；我们知道以Cloud Foundry为代表的PaaS提供了一套完整的打包功能，但是也正是这个打包功能受到了用户的诟病，被诟病的原因是：一旦用上了PaaS，用户就必须为每种语言，每种框架，甚至每个版本都维护一个打好的包，这个打包的过程没有任何章法可循，更麻烦的是在本地明明运行好好的应用，却需要很多修改和配置工作才能在PaaS中运行起来，而这些修改和配置没有任何经验可以借鉴，基本上得不断试错；而Docker解决的就是这个打包这个根本性的问题。所谓Docker镜像：其实就是一个压缩包，但是这个压缩包里的内容，比PaaS的应用的可执行文件更加的丰富，大多数的Docker镜像直接由一个完整的操作系统的所有文件和目录构成的，所以这个压缩包里的内容和我们本地开发及测试中是完全一样的。
  >
  > 更重要的是，docker这个镜像压缩包包含了完整的操作系统文件和目录，也就是包含了这个应用运行所需要的所有依赖，比如我们可以先在本地使用这个压缩包进行开发和测试，完成之后，再把这个压缩包上传到云端运行，在这个过程中，你完全不需要进行任何配置或者修改，因为这个压缩包赋予了你一种极其宝贵的能力：本地环境和云端环境高度一致。
  >
  > docker镜像消除了环境的差异，可以在互联网上分享（例如在docker官方的docker hub镜像仓库）。
  >
  > **总之，Docker项目给PaaS世界带来了降维打击，其实是提供了一种非常便利的打包机制。这种机制直接打包了应用运行所需的整个操作系统，从而保证了本地环境和云端环境的高度一致，避免了用户通过试错来匹配两种不同的运行环境之间的差异。**
  >
  > **容器本身没有价值，有价值的是容器编排，容器技术的生态爆发了一场关于容器编排的战争，最终以Kubernetes项目和CNCF社区的胜利而告终。**

### 容器是啥？

容器其实是一种沙盒技术。顾名思义，沙盒就像一个集装箱一样，我们把应用装进集装箱之中，这样应用的运行他们之间不相互干扰；而被装进集装箱的应用，也可以被方便的搬来搬去，这就是PaaS最理想的状态。

容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个**边界**。对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。

### 创建容器

```shell
docker run -it busybox /bin/sh
```

这个操作就是容器的 docker run

-it 参数告诉了Docker项目在启动容器以后，给我们分配一个文本输入、输出的环境，也就是TTY，跟容器的标准输入相关联，这样我们就可以和这个docker容器进行交互了。而 /bin/sh 就是我们需要在容器中运行的程序（命令）。所以这条命令翻译过来就是：帮我启动一个容器，在容器里面执行/bin/sh，而且给我分配一个命令行终端跟这个容器进行交互。



### 容器隔离机制的最基本原理

在创建容器进程时，指定了这个进程所需要启用的一组Namespace参数。这样，容器就只能看到当前Namespace所限定的资源、文件、设备、状态、配置，而对于宿主机及其他不相关的程序，它就完全看不到了。

> Namespace机制：它其实只是Linux创建新进程的一个可选参数，比如我们用**clone()**系统调用创建一个新的进程时，可以在参数中指定CLONE_NEWPID参数，比如：
>
> ```shell
> int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
> ```
>
> 这时，新创建的这个进程将会看到一个全新的进程空间，而这个进程空间中，它的PID就是1。之所以说“看到”，其实只是一个**障眼法**而已。在宿主机真实的进程空间里，这个进程的PID还是真实的数值，比如100。

> **问1：docker容器的隔离机制是怎么实现的？**
>
> 答：我们在启动docker容器的时候，会启动一个进程，这个进程运行在一个新的Namespace当中，这个进程就就是当前Namespace中的1号进程，它只能访问当前Namespace里挂载的目录和文件，只能访问各自Namespace中的网络设备，就仿佛运行在一个个的容器当中，与世隔绝。总之，容器就是一个在宿主机上加了namespace限定参数的进程。
>
> 我们可以找到一个运行中的容器，查看运行该容器进程的命令：
>
> ```shell
> docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/68d9d634b5e20b328b7c2fa96245ade658251ed31e905a9f18bcfb69120baa54 -address /var/run/docker/containerd/docker-containerd.sock -containerd-binary /usr/bin/docker-containerd -runtime-root /var/run/docker/runtime-runc -systemd-cgroup
> ```
>
> 
>
> **问2：容器是一个单进程，如果我们在容器中集成了jdk，netstat，ping等，虽然这个容器在启动时是一个单进程，但是我们可以在容器中执行各种命令，哪些命令也会运行一个个进程，这样不就违背了docker的单进程思想了吗？**
>
> 答：除了docker容器的主进程外，还可以在里面运行各种其他的进程，但是哪些进程是不受docker控制的。所以单进程的意思不是只能运行一个进程，而是只有一个进程是可控的。
>
> 例如：
>
> ```shell
> 1.进入一个docker容器，并在进入后执行 /bin/sh 命令，回到宿主机执行ps命令
> [root@lee ~]# ps -ef|grep '/bin/sh'
> root     21034 21001  0 22:07 pts/0    00:00:00 /bin/sh
> root     21222  1040  0 22:07 pts/1    00:00:00 docker run -it busybox /bin/sh
> root     21323 21291  0 22:07 pts/0    00:00:00 /bin/sh
> root     21728   694  0 22:08 pts/0    00:00:00 grep --color=auto /bin/sh
> 2.停掉此docker容器，然后再执行ps命令，此时已经看不到 sh进程了
> [root@lee ~]# ps -ef|grep '/bin/sh'
> root     25233   694  0 22:11 pts/0    00:00:00 grep --color=auto /bin/sh
> ```
>
> 

