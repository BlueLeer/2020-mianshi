# JVM面试题

## 1.说说下面代码在jdk 1.6和jdk 1.7时运行的区别，并简述原因：

```java
String s1 = new String("abc");
String s2 = s1.intern();

// JDK 1.6 输出为false
// JDK 1.7及以上输出为true
System.out.println(s1 == s2);
```

通过 `new String("abc")` 会在堆上创建一个字符串对象，`s1.intern()`在JDK1.7以前的执行原理是：先在字符串常量池中查找 `abc` 这个常量字符串，如果找到了就直接返回地址，如果找不到，就会将堆中的`abc`字符串先添加到常量池，然后再将地址返回；JDK 1.7及以后版本，常量池中已经不需要额外的保留一份`abc`常量了，也就是说s1.intern()的操作原理是：先在字符串常量池中查找`abc`这个常量，如果存在就直接返回，如果不存在，就直接将堆中的该字符串引用存在常量池中。

## 2.方法区（运行时常量池+字符串常量池）满了，会抛出什么异常？

会抛出 OutOfMemoryError异常

## 3.了解堆外内存吗，简单介绍下？

其实并不太了解，暂时，可以通过一个有接触过的NIO进行解释。

堆外内存也叫作**直接内存**。

NIO是在Java 1.4时引入的，也称作 New Input/Output，它是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块儿内存的引用进行操作。

## 4.JVM常见配置参数？

-`Xms`  初始堆大小

`-Xmx`  最大堆大小，建议Xmx和Xms相同，避免每次垃圾回收完成后JVM重新分配内存

`-Xmn`  年轻代大小。堆大小=年轻代大小+年老代大小，sun官方给出的建议是，将年轻代大小设置为：堆大小*3/8

`-Xss`  每个线程堆栈的大小。小应用栈大小一般128KB，大应用一般256KB，对性能影响比较大，需要严格测试。

`-XX:NewSize=n` 年轻代大小

`-XX:NewRatio=n` 年老代:年轻代比值

`-XX:SurvivorRatio=n` 年轻代中 Eden:FromSurvivor:ToSurvivor=n:1:1

`-XX:PretenureSizeThreshold` 直接晋升到老年代对象大小

`-XX:MaxTenuringThreshold=0` 垃圾最大年龄为0

`-XX:PermSize=10M` 永久代(perm gen)初始值为10MB。默认为物理内存的1/64

`-XX:MaxPermSize=10M` 持久代最大值为10MB。物理内存的1/4

垃圾回收统计信息:

-XX:+PrintGC

-XX:+PrintGCDetails  

-XX:+PrintGCTimeStamps  

-XX:+PrintGCDateStamps — 打印GC操作的时间戳 

-Xloggc:filename :把相关日志信息记录到文件以便分析。

-XX:PrintHeapAtGC ：打印GC前后的详细堆栈信息 

## 5.什么是Java堆溢出？说说出现你是怎么详细定位这类问题并快速分析的。

Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆容量的限制后就会产生内存溢出异常。我们可以通过设置参数：`-XX:+HeapDumpOnOutOfMemoryError` 可以让虚拟机出现内存溢出异常时Dump出当前的内存堆转储快照，然后通过内存映像分析工具（例如 jdk自带的Jvisualvm工具）进行分析，重点是确认内存中的对象是否必要的，也就是要先分析清楚到底是出现了内存溢出（Memory Overflow）还是内存泄漏（Memory Leak）。

如果是内存溢出，那么就要检查虚拟机的堆参数（-Xmx和-Xms），与机器的物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗。如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息和GC Roots引用链信息，就可以比较准确的定位出泄漏代码的位置。

这是处理Java堆问题的简单思路。

> 什么是内存溢出，什么是内存泄漏？
>
> 它们都会引发 OutOfMemoryError，区别是内存溢出是对象都是必须的，但是放对象的堆空间不够用了；而内存泄漏是因为对象到GC Roots是可达的，导致大量不必要存在的对象依然存在着无法被回收，从而引发内存泄漏。

## 6.简单谈谈 虚拟机栈和本地方法栈溢出。

在HotSpot虚拟机里面是不区分 虚拟机栈和本地方法栈的，它们二者很相似，区别主要在于，虚拟机栈是执行Java方法的，而本地方法栈是执行native方法。关于虚拟机栈和本地方法栈，Java虚拟机规范中的描述，共有2中异常会抛出：

* StackOverflowError

  如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError异常。

* OutOfMemoryError

  当前大部分Java虚拟机都可以动态扩展，如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

这2种划分方式看似很严谨，其实存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是栈深度太深了。通常情况下，更多的是会抛出StackOverflowError异常。虚拟机消耗内存最大值=最大堆容量+最大方法区容量+（程序计数器耗用内存+虚拟机栈和本地方法栈耗用内存）* 线程数。通常情况下，使用虚拟机默认的参数，栈深度在大多数情况下达到1000~2000完全没有问题（因为每个方法压入栈的帧大小并不是一样的，所以只能说在大多数情况下），对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果在建立过多的线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少堆大小或者减少线程栈容量来容纳更多的线程。

## 7.谈谈你对方法区和运行时常量池溢出的理解。

运行时常量池是方法区的一部分。在JDK 1.6及之前的版本，因为常量池分配在永久代（方法区的实现，也可以说是方法区的俗称）中，我们可以通过`-XX:MaxPermSize`限制永久代的大小，从而限制运行时常量池的大小。我们知道运行时常量池主要放了Class相关信息，如类名、访问修饰符、常量池（此常量池是运行时常量池的子集，主要存放编译期生成的各种字面量额符号引用，这部分将在类加载后进入方法区的运行时常量池中存放，eg:《深入理解Java虚拟机》P42）、字段描述、方法描述等。对于这部分的溢出，常见的溢出原因是运行时产生了大量的类，方法区被逐渐填满。例如使用Java反射和动态代理（Java动态代理、CGLib）动态的产生大量的类。当前的很多主流框架，例如Spring、Hibernate在对类进行增强时，都会用到动态代理这类技术，增强的越多，就需要越多空间的方法区来保证动态生成的Class可以载入内存。除了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。

## 8.了解本地直接内存溢出吗，简单谈谈。

本地直接内存，Native Direct Memory，也就是堆外内存。堆外内存的容量可以通过`-XX:MaxDirectMemorySize=nM`指定，如果不指定，则默认与Java堆的最大值（Xmx指定）一样。直接内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果我们发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。





# JVM面试题-垃圾收集器与内存分配策略

1. 目前内存回收技术已经这么成熟了，那么为什么我们还要去了解GC和内存分配呢？

   当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集器成为系统达到高并发量的瓶颈时，我们需要对这些“自动化”的技术实施必要的监控和调节。

2. 我们知道 虚拟机栈和本地方法栈里面的结构是一个个的栈帧，谈谈你对栈帧的理解

   每个方法在执行的时候都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈，方法出口等信息。

   * 局部变量表：它是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量
   * 操作数栈：虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。 

   每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。每一个栈帧中分配多少内存是在类结构确定下来时就已知了。因为类结构确定后，方法的变量数量也会确定下来，基本类型所占的空间很好确定，而引用类型的变量存储了引用地址而不参与栈帧内存分配。

3. 说说虚拟机是如何确定对象是否“存活”，确定对象是否存活有哪些算法，各有什么特点？

   确定对象是否存活有2中算法：

   1. 引用计数算法

      给对象添加一个引用计数器，每当有一个地方引用它时，计数器就增加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。有许多案例都应用过引用计数算法进行内存管理，但是主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的问题是它很难解决对象之间相互循环引用的问题。

   2. 可达性分析算法

      在主流的商用编程语言（Java、C#）的主流实现中，都是通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

      在Java语言中，可作为GC Roots的对象包括下面几种：

      * 虚拟机栈（栈帧中的本地变量表）中引用的对象
      * 方法区中类静态属性引用的对象
      * 方法区中常量引用的对象
      * 本地方法栈中JNI（即一般说的Native方法）引用的对象

4. Java中有哪些类型的引用，分别谈谈你对他们的认识。

   在早期（JDK 1.2以前），Java中定义的引用很纯粹，一个对象只有被引用和没有被引用两种状态，但是对于哪些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能够描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集以后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。那些对象可以参与上面的过程？Java将引用分为了强引用、软引用、弱引用、虚引用4种，这4种引用强度依次逐渐减弱。

   * 强引用 

     在程序中普遍存在的，类似于`Object o = new Object();`，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

   * 软引用

     用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了`SoftReference` 类来实现软引用。

   * 弱引用

     也是用来描述非必须对象的，但是它的强度比软引用还要弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，不管内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了`WeakReference`类来实现弱引用。

   * 虚引用

     虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK 1.2之后，提供了`PhantomReference`类来实现虚引用。

5. 堆中一个对象死亡了，会经历几次标记过程？请简述。

   Java使用的是可达性分析算法，对于不可达的对象，也并非是非死不可的，这时候他们暂时处于“缓刑”阶段，要真正的宣告一个对象死亡，至少要经历**2次**标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连的引用链，那它将会被第一次标记并且进行一次筛选：筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者该方法已经被执行过了，那么就被认定为没有必要执行，将会被标记为“**可回收**”；如果这个独享覆盖了finalize方法并且没有被执行过，那么这个对象将会被放置在一个叫做 `F-Queue` 的队列之中，并在稍后有一个虚拟机自动建立的、低优先级的 `Finalizer` 线程去执行它，这里的“执行”是指虚拟机会触发这个方法，但是并不保证会等它运行结束（这样做的目的是怕对象的finalize方法执行缓慢或者有个死循环，那么就会导致F-Queue队列中其他对象永远处于等待，因此我们可以得出，不要指望finalize方法去帮我们执行一些其他的逻辑，因为它不可靠）。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将堆F-Queue中的对象进行第二次小规模的标记，如果在finalize方法中没有拯救自己，那么这次就要被回收了。

   > 问：我们可以在finalize()方法中做一些"关闭外部资源"的操作吗？
   >
   > 不可以的。这个方法是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高，不确定性大，无法保证各个对象的调用顺序。因为虚拟机自动创建的Finalizer线程优先级低，无法保证执行时序。而且也不保证一定让它执行完。我们有`try-finally` 或者 `try-resource` 等更好、更及时、更可靠的方式。其实我们可以完全忘记这个方法的存在。

   ![对象被回收前的两次标记过程](对象被回收前的2次标记过程.png)

6. 方法区会被回收吗？

   方法区俗称为“永久代”，永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量时，假如字符创常量池中的一个字符串没有被任何String对象引用，也没有其他地方应用这个字面量，如果这个时候发生了内存回收，那这个常量就会被系统清理出常量池；判定一个常量是否“废弃常量”比较简单，而要判定一个类是否是“**无用的类**”的条件相对就会苛刻很多。类需要同时满足一下3个条件才能算是“无用的类”：

   1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
   2. 加载该类的`ClassLoader`已经被回收
   3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

   虚拟机可以对满足上述3个条件的无用类进行回收，仅仅是可以，并不会像对象一样，不使用了必然被回收。是否对类进行回收，HotSpot虚拟机提供了 `-Xnoclassgc` 参数进行控制。在大量使用反射、动态代理、CGLib、动态生成JSP这种频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

7. 待续。。。2020年2月29日21:30

   

    





# 扩展

1. 说说你对类加载器的理解

   java中的类加载器有三种：

   * 引导类加载器（BootStrapClassLoader）加载`jre/lib/rt.jar`
   * 扩展类加载器（ExtendClassLoader）加载`jre/lib/ext`目录下的jar包
   * 应用类加载器（AppClassLoader）加载当前应用的classpath中的类,包括引入的第三方jar包,还有自己写的java类

   JVM的类加载机制主要有下面三种：

   1. 委托机制(双亲委派)

      向让父类加载器先去试图加载该Class，只有在父类加载器无法加载该类的时候才会尝试从自己的类路径去加载，如果父类加载器加载到并成功返回了，则直接返回该类。好处是安全。

   2. 全盘负责

      当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入，除非显示的指定使用另一个类加载器。

   3. 缓存机制

      保证所有已经被加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存中搜寻该Class，只有当缓存中不存在该类时，系统才会读取class文件然后重新转换成Class对象，存入缓冲区中。这就是为什么修改了Class以后，必须重新启动JVM，程序所做的修改才会生效的原因。