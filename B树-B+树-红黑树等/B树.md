# B树、B+树

如果有海量的数据，例如数据库中千万级别甚至亿级别的数据，这些数据不可能一次性的读取到内存中，这时候需要考虑的是，如何在磁盘中快速的找到需要的数据。B树和B+树派上用场了，它们在应对**查找磁盘中大量的数据**这一场景下非常合适。



## B树

B树就是常说的“B树（B-树，中间的-不是减号的意思），又名**多路平衡查找树**，B为平衡（Balance）的意思，不是二分（Binary）的意思。多路，意思是节点的子树不止2个。

接下来看下B树的定义：

1. 若根节点不是终端节点，则至少有2棵子树；
2. B树每个节点可以有多个子树，M阶B树表示任一节点最多拥有M个子树，任一结点最多有M-1个关键字；
3. B树的每个中间节点有k-1个关键字和k个子树（M/2 <= k <= M，M/2向上取整），中间节点的关键字为k-1个。举个栗子：一个3阶的B树，任一中间节点最多能有3个子树，最少有 2个子树；
4. 所有的叶子节点都在同一层；

B树示意图：

![](B-树.png)



**插入流程：**

1. 根据要插入的key的值，找到叶子结点并插入。

2. 判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。

3. 以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

一定要去看看这篇博文，加深你的理解：https://www.cnblogs.com/nullzx/p/8729425.html>



**查找流程：**

因为 B 树的子树大小排序规则，因此在 B 树中查找数据时，一般需要这样：

1. 从根节点开始，如果查找的数据比根节点小，就去左子树找，否则去右子树
2. 和子树的多个关键字进行比较，找到它所处的范围，然后去范围对应的子树中继续查找
3. 以此循环，直到找到或者到叶子节点还没找到为止



**B树如何保证平衡：**

B本来就是平衡之意，那就一定有一种机制保证它的平衡性。B树的限制条件决定了什么时候应该做出调整，B树平衡的条件有三点：

1. 叶子节点都在同一层
2. 每个节点的关键字为子树的个数减1（子树的个数介于M到M/2之间,M/2向上取整）
3. 子树的关键字保证从小到大排列

太难得演示了，会手撕就行了，O(∩_∩)O哈哈~

建议网上找找其他的博客看看，很多的。



## B+树

B+树是B树的变形版，它比B树的查询性能更高。

一棵B+树必须满足以下条件：

1. **结点的子树和该结点的关键字个数一样**

   B树中关键字代表了各个子树的取值区间，因此关键字肯定要比子树少1；而B+树的关键字是各个子结点的最大值，因此关键字和子树的数目一致。

2. 结点的关键字是子结点的最大值，并且这个最大值在子结点中也有

   除叶子结点外，其他的结点的关键字都是子树中的最大值，也就是说关键字在子结点中同样存着的

3. 叶子节点从大到小排序，并且叶子结点指向了右边的叶子结点（相当于一个指针，单链表），同时叶子结点包含了全部的数据

   叶子结点包含了所有的关键字，并且包含了数据，它们按照顺序排列起来，并且用指针连接起来，这样查询时效率更快。



由于B+树的中间结点不含有实际的数据，只有子树的最大值和到子树的指针，因此磁盘中可以容纳更多的节点元素，也就是说数据情况下，B+树会比B树更加的“矮胖”。



B+树的优点：

1. 层级更低，IO次数更少
2. 数据是放在叶子结点上的，每次查询都会查询到叶子结点上，查询性能稳定
3. 叶子结点形成了有序的链表，范围查询更方便。





参考：

<https://blog.csdn.net/u011240877/article/details/80490663>

<https://www.cnblogs.com/nullzx/p/8729425.html>

